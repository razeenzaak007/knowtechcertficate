/**
 * @fileOverview Firestore Security Rules for Certificate Generation App.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles, Excel uploads, recipient data, and certificate templates.
 * Certificates are secured based on the creator and template owners.
 * Administrative privileges are granted based on the existence of a document in the /roles_admin/{uid} collection.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Only the user can access their profile.
 * - /users/{userId}/excelUploads/{excelUploadId}: Stores Excel upload metadata. Only the user can access their uploads.
 * - /users/{userId}/excelUploads/{excelUploadId}/recipientData/{recipientDataId}: Stores recipient data from Excel files. Inherits ownership from the parent /excelUploads collection.
 * - /certificateTemplates/{certificateTemplateId}: Stores certificate templates. The userId of the template owner is stored in the document.
 * - /certificates/{certificateId}: Stores generated certificates. Contains references to the template and recipient data, as well as the userId of the certificate creator.
 * - /roles_admin/{uid}: Documents in this collection grant admin privileges to the user with the corresponding `uid`.
 *
 * Key Security Decisions:
 * - Users can only access their own data under their /users/{userId} path.
 * - Listing of users is disallowed.
 * - Certificates are secured based on the creator and template owners.
 * - Administrative privileges are granted based on the existence of a document in the /roles_admin/{uid} collection.
 *
 * Denormalization for Authorization:
 * - The userId of the template owner is copied to certificate documents to avoid hierarchical authorization dependencies and enable Authorization Independence.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the resource based on the provided userId.
     * @param {string} userId The user ID to compare against the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the resource, and the resource exists.
     * @param {string} userId The user ID to compare against the resource's userId.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the current user is an admin by checking if a document exists under /roles_admin/{uid}.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description
     * Rule for the /users/{userId} collection.
     * Allows users to read and write their own profile data.
     *
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates a profile with ID 'user123'.
     *     request.auth.uid == 'user123'
     *     request.resource.data.id == 'user123'
     * @deny (update) User with ID 'user123' tries to update profile with ID 'user456'.
     *     request.auth.uid == 'user123'
     *     resource.data.id == 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not allowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description
     * Rule for the /users/{userId}/excelUploads/{excelUploadId} collection.
     * Allows users to manage their own Excel uploads.
     *
     * @path /users/{userId}/excelUploads/{excelUploadId}
     * @allow (create) User 'user123' creates an Excel upload with userId 'user123'.
     *     request.auth.uid == 'user123'
     *     request.resource.data.userId == 'user123'
     * @deny (update) User 'user123' tries to update an Excel upload belonging to 'user456'.
     *     request.auth.uid == 'user123'
     *     resource.data.userId == 'user456'
     * @principle Enforces document ownership for writes and validates relational integrity.
     */
    match /users/{userId}/excelUploads/{excelUploadId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description
     * Rule for the /users/{userId}/excelUploads/{excelUploadId}/recipientData/{recipientDataId} collection.
     * Allows users to manage recipient data within their Excel uploads.
     *
     * @path /users/{userId}/excelUploads/{excelUploadId}/recipientData/{recipientDataId}
     * @allow (create) User 'user123' creates recipient data within their Excel upload.
     *     request.auth.uid == 'user123'
     *     get(/databases/$(database)/documents/users/$(userId)/excelUploads/$(excelUploadId)).data.userId == 'user123'
     * @deny (delete) User 'user456' tries to delete recipient data within 'user123's Excel upload.
     *     request.auth.uid == 'user456'
     *     get(/databases/$(database)/documents/users/$(userId)/excelUploads/$(excelUploadId)).data.userId == 'user123'
     * @principle Inherits ownership from the parent /excelUploads collection.
     */
    match /users/{userId}/excelUploads/{excelUploadId}/recipientData/{recipientDataId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && get(/databases/$(database)/documents/users/$(userId)/excelUploads/$(excelUploadId)).data.userId == userId;
      allow update: if isOwner(userId) && get(/databases/$(database)/documents/users/$(userId)/excelUploads/$(excelUploadId)).data.userId == userId;
      allow delete: if isOwner(userId) && get(/databases/$(database)/documents/users/$(userId)/excelUploads/$(excelUploadId)).data.userId == userId;
    }

     /**
      * @description
      * Rule for the /certificateTemplates/{certificateTemplateId} collection.
      * Allows create, read, update, and delete operations only by the owner (userId in document).
      *
      * @path /certificateTemplates/{certificateTemplateId}
      * @allow (create) User creates a new certificate template where the userId matches their auth.
      *     request.auth.uid == request.resource.data.userId
      * @deny (update) User tries to update a certificate template that they don't own.
      *     request.auth.uid != resource.data.userId
      * @principle Enforces document ownership for all operations.
      */
    match /certificateTemplates/{certificateTemplateId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /**
     * @description
     * Rule for the /certificates/{certificateId} collection.
     * Allows read access to all. Write access is restricted to the certificate creator.
     *
     * @path /certificates/{certificateId}
     * @allow (get) Any user can read a certificate.
     *     true
     * @allow (create) User creates a certificate and their ID matches the certificate's userId.
     *     request.auth.uid == request.resource.data.userId
     * @deny (update) User tries to update a certificate they didn't create.
     *     request.auth.uid != resource.data.userId
     * @principle Allows public read access but restricts write access to the owner.
     */
    match /certificates/{certificateId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

     /**
      * @description
      * Rule for the /roles_admin/{uid} collection.
      * Admin role assignment. Only existence of the document is checked.
      *
      * @path /roles_admin/{uid}
      * @allow (get) Anyone can check for admin status (for testing purposes only, should be secured later).
      *     true
      * @allow (create) Only an existing admin can assign another admin.
      *     isAdmin()
      * @deny (delete) Non-admins cannot delete admin roles.
      *     !isAdmin()
      * @principle Admin role is granted based on document existence.
      */
    match /roles_admin/{uid} {
      allow get: if true; //For testing, should be secured later
      allow list: if false;
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin();
    }
  }
}